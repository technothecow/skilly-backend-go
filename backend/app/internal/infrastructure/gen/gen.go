// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// CheckUsernameResponse defines model for CheckUsernameResponse.
type CheckUsernameResponse struct {
	// Available Whether the username is available or not.
	Available bool `json:"available"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code.
	Code string `json:"code"`

	// Details Optional additional details about the error.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message A human-readable description of the error.
	Message *string `json:"message,omitempty"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	// Password Password to login.
	Password string `json:"password"`

	// Username Username to login.
	Username string `json:"username"`
}

// ProfileEditRequest defines model for ProfileEditRequest.
type ProfileEditRequest struct {
	// Bio Short user biography.
	Bio *string `json:"bio,omitempty"`

	// Learning Skills the user wants to learn.
	Learning *[]string `json:"learning,omitempty"`

	// Password New password for the user.
	Password *string `json:"password,omitempty"`

	// Teaching Skills the user is willing to teach.
	Teaching *[]string `json:"teaching,omitempty"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	// Bio Bio to register.
	Bio string `json:"bio"`

	// Learning Skills to learn.
	Learning []string `json:"learning"`

	// Password Password to register.
	Password string `json:"password"`

	// Teaching Skills to teach.
	Teaching []string `json:"teaching"`

	// Username Username to register.
	Username string `json:"username"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// Page Page number to retrieve.
	Page int32 `json:"page"`

	// Pagesize Number of items to retrieve per page.
	Pagesize int32 `json:"pagesize"`

	// Skills Skills to search.
	Skills []string `json:"skills"`

	// Username Username to search.
	Username string `json:"username"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {
	// Bio Short user biography.
	Bio string `json:"bio"`

	// Learning Skills the user wants to learn.
	Learning []string `json:"learning"`

	// PictureUrl URL to the user's avatar image.
	PictureUrl string `json:"pictureUrl"`

	// Teaching Skills the user is willing to teach.
	Teaching []string `json:"teaching"`

	// Username Username of the user.
	Username string `json:"username"`
}

// UsernameParam defines model for UsernameParam.
type UsernameParam = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// PongResponse defines model for PongResponse.
type PongResponse struct {
	// Message Pong message
	Message string `json:"message"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Users []UserProfile `json:"users"`
}

// SetPictureResponse defines model for SetPictureResponse.
type SetPictureResponse struct {
	// Url URL to the user's avatar image.
	Url string `json:"url"`
}

// GetCheckUsernameParams defines parameters for GetCheckUsername.
type GetCheckUsernameParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostProfileViewParams defines parameters for PostProfileView.
type PostProfileViewParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody = LoginRequest

// PostProfileEditJSONRequestBody defines body for PostProfileEdit for application/json ContentType.
type PostProfileEditJSONRequestBody = ProfileEditRequest

// PostRegisterJSONRequestBody defines body for PostRegister for application/json ContentType.
type PostRegisterJSONRequestBody = RegisterRequest

// PostSearchJSONRequestBody defines body for PostSearch for application/json ContentType.
type PostSearchJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Check if given username is available
	// (GET /check-username)
	GetCheckUsername(c *gin.Context, params GetCheckUsernameParams)
	// Login a user
	// (POST /login)
	PostLogin(c *gin.Context)
	// Logout the current user
	// (POST /logout)
	PostLogout(c *gin.Context)
	// Ping the server
	// (GET /ping)
	GetPing(c *gin.Context)
	// Edit the current user's profile
	// (POST /profile/edit)
	PostProfileEdit(c *gin.Context)
	// Set the current user's profile picture
	// (POST /profile/set_picture)
	PostProfileSetPicture(c *gin.Context)
	// View the user's profile
	// (POST /profile/view)
	PostProfileView(c *gin.Context, params PostProfileViewParams)
	// Register a new user
	// (POST /register)
	PostRegister(c *gin.Context)
	// Search for users
	// (POST /search)
	PostSearch(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetCheckUsername operation middleware
func (siw *ServerInterfaceWrapper) GetCheckUsername(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheckUsernameParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCheckUsername(c, params)
}

// PostLogin operation middleware
func (siw *ServerInterfaceWrapper) PostLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogin(c)
}

// PostLogout operation middleware
func (siw *ServerInterfaceWrapper) PostLogout(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogout(c)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPing(c)
}

// PostProfileEdit operation middleware
func (siw *ServerInterfaceWrapper) PostProfileEdit(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileEdit(c)
}

// PostProfileSetPicture operation middleware
func (siw *ServerInterfaceWrapper) PostProfileSetPicture(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileSetPicture(c)
}

// PostProfileView operation middleware
func (siw *ServerInterfaceWrapper) PostProfileView(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProfileViewParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileView(c, params)
}

// PostRegister operation middleware
func (siw *ServerInterfaceWrapper) PostRegister(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostRegister(c)
}

// PostSearch operation middleware
func (siw *ServerInterfaceWrapper) PostSearch(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSearch(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/check-username", wrapper.GetCheckUsername)
	router.POST(options.BaseURL+"/login", wrapper.PostLogin)
	router.POST(options.BaseURL+"/logout", wrapper.PostLogout)
	router.GET(options.BaseURL+"/ping", wrapper.GetPing)
	router.POST(options.BaseURL+"/profile/edit", wrapper.PostProfileEdit)
	router.POST(options.BaseURL+"/profile/set_picture", wrapper.PostProfileSetPicture)
	router.POST(options.BaseURL+"/profile/view", wrapper.PostProfileView)
	router.POST(options.BaseURL+"/register", wrapper.PostRegister)
	router.POST(options.BaseURL+"/search", wrapper.PostSearch)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//9XOLc1xGgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
