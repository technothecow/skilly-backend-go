// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// CheckUsernameResponse defines model for CheckUsernameResponse.
type CheckUsernameResponse struct {
	// Available Whether the username is available or not.
	Available bool `json:"available"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code.
	Code string `json:"code"`

	// Details Optional additional details about the error.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message A human-readable description of the error.
	Message *string `json:"message,omitempty"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	// Password Password to login.
	Password string `json:"password"`

	// Username Username to login.
	Username string `json:"username"`
}

// ProfileEditRequest defines model for ProfileEditRequest.
type ProfileEditRequest struct {
	// Bio Short user biography.
	Bio *string `json:"bio,omitempty"`

	// Learning Skills the user wants to learn.
	Learning *[]string `json:"learning,omitempty"`

	// Password New password for the user.
	Password *string `json:"password,omitempty"`

	// Teaching Skills the user is willing to teach.
	Teaching *[]string `json:"teaching,omitempty"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	// Bio Bio to register.
	Bio string `json:"bio"`

	// Learning Skills to learn.
	Learning []string `json:"learning"`

	// Password Password to register.
	Password string `json:"password"`

	// Teaching Skills to teach.
	Teaching []string `json:"teaching"`

	// Username Username to register.
	Username string `json:"username"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// Page Page number to retrieve.
	Page *int32 `json:"page,omitempty"`

	// Pagesize Number of items to retrieve per page.
	Pagesize *int32 `json:"pagesize,omitempty"`

	// Skills Skills to search.
	Skills *[]string `json:"skills,omitempty"`

	// Username Username to search.
	Username *string `json:"username,omitempty"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {
	// Bio Short user biography.
	Bio string `json:"bio"`

	// Learning Skills the user wants to learn.
	Learning []string `json:"learning"`

	// PictureUrl URL to the user's avatar image.
	PictureUrl string `json:"pictureUrl"`

	// Teaching Skills the user is willing to teach.
	Teaching []string `json:"teaching"`

	// Username Username of the user.
	Username string `json:"username"`
}

// UsernameParam defines model for UsernameParam.
type UsernameParam = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// PongResponse defines model for PongResponse.
type PongResponse struct {
	// Message Pong message
	Message string `json:"message"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Users []UserProfile `json:"users"`
}

// SetPictureResponse defines model for SetPictureResponse.
type SetPictureResponse struct {
	// Url URL to the user's avatar image.
	Url string `json:"url"`
}

// GetCheckUsernameParams defines parameters for GetCheckUsername.
type GetCheckUsernameParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostProfileViewParams defines parameters for PostProfileView.
type PostProfileViewParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody = LoginRequest

// PostProfileEditJSONRequestBody defines body for PostProfileEdit for application/json ContentType.
type PostProfileEditJSONRequestBody = ProfileEditRequest

// PostRegisterJSONRequestBody defines body for PostRegister for application/json ContentType.
type PostRegisterJSONRequestBody = RegisterRequest

// PostSearchJSONRequestBody defines body for PostSearch for application/json ContentType.
type PostSearchJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Check if given username is available
	// (GET /check-username)
	GetCheckUsername(c *gin.Context, params GetCheckUsernameParams)
	// Login a user
	// (POST /login)
	PostLogin(c *gin.Context)
	// Logout the current user
	// (POST /logout)
	PostLogout(c *gin.Context)
	// Ping the server
	// (GET /ping)
	GetPing(c *gin.Context)
	// Edit the current user's profile
	// (POST /profile/edit)
	PostProfileEdit(c *gin.Context)
	// Set the current user's profile picture
	// (POST /profile/set_picture)
	PostProfileSetPicture(c *gin.Context)
	// View the user's profile
	// (POST /profile/view)
	PostProfileView(c *gin.Context, params PostProfileViewParams)
	// Register a new user
	// (POST /register)
	PostRegister(c *gin.Context)
	// Search for users
	// (POST /search)
	PostSearch(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetCheckUsername operation middleware
func (siw *ServerInterfaceWrapper) GetCheckUsername(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheckUsernameParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCheckUsername(c, params)
}

// PostLogin operation middleware
func (siw *ServerInterfaceWrapper) PostLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogin(c)
}

// PostLogout operation middleware
func (siw *ServerInterfaceWrapper) PostLogout(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogout(c)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPing(c)
}

// PostProfileEdit operation middleware
func (siw *ServerInterfaceWrapper) PostProfileEdit(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileEdit(c)
}

// PostProfileSetPicture operation middleware
func (siw *ServerInterfaceWrapper) PostProfileSetPicture(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileSetPicture(c)
}

// PostProfileView operation middleware
func (siw *ServerInterfaceWrapper) PostProfileView(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProfileViewParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileView(c, params)
}

// PostRegister operation middleware
func (siw *ServerInterfaceWrapper) PostRegister(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostRegister(c)
}

// PostSearch operation middleware
func (siw *ServerInterfaceWrapper) PostSearch(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSearch(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/check-username", wrapper.GetCheckUsername)
	router.POST(options.BaseURL+"/login", wrapper.PostLogin)
	router.POST(options.BaseURL+"/logout", wrapper.PostLogout)
	router.GET(options.BaseURL+"/ping", wrapper.GetPing)
	router.POST(options.BaseURL+"/profile/edit", wrapper.PostProfileEdit)
	router.POST(options.BaseURL+"/profile/set_picture", wrapper.PostProfileSetPicture)
	router.POST(options.BaseURL+"/profile/view", wrapper.PostProfileView)
	router.POST(options.BaseURL+"/register", wrapper.PostRegister)
	router.POST(options.BaseURL+"/search", wrapper.PostSearch)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"s/k3AAD//9fBMxdUGwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
