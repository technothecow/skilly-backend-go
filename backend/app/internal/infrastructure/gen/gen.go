// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// CheckUsernameResponse defines model for CheckUsernameResponse.
type CheckUsernameResponse struct {
	// Available Whether the username is available or not.
	Available bool `json:"available"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code.
	Code string `json:"code"`

	// Details Optional additional details about the error.
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message A human-readable description of the error.
	Message *string `json:"message,omitempty"`
}

// LoginRequest defines model for LoginRequest.
type LoginRequest struct {
	// Password Password to login.
	Password string `json:"password"`

	// Username Username to login.
	Username string `json:"username"`
}

// ProfileEditRequest defines model for ProfileEditRequest.
type ProfileEditRequest struct {
	// Bio Short user biography.
	Bio *string `json:"bio,omitempty"`

	// Learning Skills the user wants to learn.
	Learning *[]string `json:"learning,omitempty"`

	// Password New password for the user.
	Password *string `json:"password,omitempty"`

	// Teaching Skills the user is willing to teach.
	Teaching *[]string `json:"teaching,omitempty"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	// Bio Bio to register.
	Bio string `json:"bio"`

	// Learning Skills to learn.
	Learning []string `json:"learning"`

	// Password Password to register.
	Password string `json:"password"`

	// Teaching Skills to teach.
	Teaching []string `json:"teaching"`

	// Username Username to register.
	Username string `json:"username"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// Page Page number to retrieve.
	Page *int32 `json:"page,omitempty"`

	// Pagesize Number of items to retrieve per page.
	Pagesize *int32 `json:"pagesize,omitempty"`

	// Skills Skills to search.
	Skills *[]string `json:"skills,omitempty"`

	// Username Username to search.
	Username *string `json:"username,omitempty"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {
	// Bio Short user biography.
	Bio string `json:"bio"`

	// Learning Skills the user wants to learn.
	Learning []string `json:"learning"`

	// Teaching Skills the user is willing to teach.
	Teaching []string `json:"teaching"`

	// Username Username of the user.
	Username string `json:"username"`
}

// UsernameParam defines model for UsernameParam.
type UsernameParam = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// GetPictureResponse defines model for GetPictureResponse.
type GetPictureResponse struct {
	// Url URL to the user's avatar image.
	Url string `json:"url"`
}

// PongResponse defines model for PongResponse.
type PongResponse struct {
	// Message Pong message
	Message string `json:"message"`
}

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Users []UserProfile `json:"users"`
}

// SetPictureResponse defines model for SetPictureResponse.
type SetPictureResponse struct {
	// Url URL to the user's avatar image.
	Url string `json:"url"`
}

// GetCheckUsernameParams defines parameters for GetCheckUsername.
type GetCheckUsernameParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// GetProfileGetPictureParams defines parameters for GetProfileGetPicture.
type GetProfileGetPictureParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostProfileViewParams defines parameters for PostProfileView.
type PostProfileViewParams struct {
	// Username Username to check.
	Username UsernameParam `form:"username" json:"username"`
}

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody = LoginRequest

// PostProfileEditJSONRequestBody defines body for PostProfileEdit for application/json ContentType.
type PostProfileEditJSONRequestBody = ProfileEditRequest

// PostRegisterJSONRequestBody defines body for PostRegister for application/json ContentType.
type PostRegisterJSONRequestBody = RegisterRequest

// PostSearchJSONRequestBody defines body for PostSearch for application/json ContentType.
type PostSearchJSONRequestBody = SearchRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Check if given username is available
	// (GET /check-username)
	GetCheckUsername(c *gin.Context, params GetCheckUsernameParams)
	// Login a user
	// (POST /login)
	PostLogin(c *gin.Context)
	// Logout the current user
	// (POST /logout)
	PostLogout(c *gin.Context)
	// Ping the server
	// (GET /ping)
	GetPing(c *gin.Context)
	// Edit the current user's profile
	// (POST /profile/edit)
	PostProfileEdit(c *gin.Context)
	// Get link to the current user's profile picture
	// (GET /profile/get_picture)
	GetProfileGetPicture(c *gin.Context, params GetProfileGetPictureParams)
	// Set the current user's profile picture
	// (POST /profile/set_picture)
	PostProfileSetPicture(c *gin.Context)
	// View the user's profile
	// (POST /profile/view)
	PostProfileView(c *gin.Context, params PostProfileViewParams)
	// Register a new user
	// (POST /register)
	PostRegister(c *gin.Context)
	// Search for users
	// (POST /search)
	PostSearch(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetCheckUsername operation middleware
func (siw *ServerInterfaceWrapper) GetCheckUsername(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheckUsernameParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetCheckUsername(c, params)
}

// PostLogin operation middleware
func (siw *ServerInterfaceWrapper) PostLogin(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogin(c)
}

// PostLogout operation middleware
func (siw *ServerInterfaceWrapper) PostLogout(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostLogout(c)
}

// GetPing operation middleware
func (siw *ServerInterfaceWrapper) GetPing(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetPing(c)
}

// PostProfileEdit operation middleware
func (siw *ServerInterfaceWrapper) PostProfileEdit(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileEdit(c)
}

// GetProfileGetPicture operation middleware
func (siw *ServerInterfaceWrapper) GetProfileGetPicture(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProfileGetPictureParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetProfileGetPicture(c, params)
}

// PostProfileSetPicture operation middleware
func (siw *ServerInterfaceWrapper) PostProfileSetPicture(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileSetPicture(c)
}

// PostProfileView operation middleware
func (siw *ServerInterfaceWrapper) PostProfileView(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostProfileViewParams

	// ------------- Required query parameter "username" -------------

	if paramValue := c.Query("username"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument username is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "username", c.Request.URL.Query(), &params.Username)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter username: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostProfileView(c, params)
}

// PostRegister operation middleware
func (siw *ServerInterfaceWrapper) PostRegister(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostRegister(c)
}

// PostSearch operation middleware
func (siw *ServerInterfaceWrapper) PostSearch(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PostSearch(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/check-username", wrapper.GetCheckUsername)
	router.POST(options.BaseURL+"/login", wrapper.PostLogin)
	router.POST(options.BaseURL+"/logout", wrapper.PostLogout)
	router.GET(options.BaseURL+"/ping", wrapper.GetPing)
	router.POST(options.BaseURL+"/profile/edit", wrapper.PostProfileEdit)
	router.GET(options.BaseURL+"/profile/get_picture", wrapper.GetProfileGetPicture)
	router.POST(options.BaseURL+"/profile/set_picture", wrapper.PostProfileSetPicture)
	router.POST(options.BaseURL+"/profile/view", wrapper.PostProfileView)
	router.POST(options.BaseURL+"/register", wrapper.PostRegister)
	router.POST(options.BaseURL+"/search", wrapper.PostSearch)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
